"""Computes performance metrics."""

import numpy as np
from tensorflow.keras import backend as K


def jaccard_score(y_true, y_pred):
    """Jaccard score.

    Parameters
    ----------
    y_true : 1d array-like, or label indicator array / sparse matrix
        Ground truth (correct) labels.
    y_pred : 1d array-like, or label indicator array / sparse matrix
        Predicted labels, as returned by a classifier.
    """
    try:
        assert(len(y_true) == len(y_pred))

        jaccard_vector = [_jaccard(str1=true, str2=pred) for true, pred in zip(y_true, y_pred)]
        jaccard_score = np.mean(jaccard_vector)
        return jaccard_score
    except AssertionError:
        print('y_true and y_pred lengths differ.')


def _jaccard(str1, str2):
    a = set(str1.lower().split())
    b = set(str2.lower().split())
    c = a.intersection(b)
    return float(len(c)) / (len(a) + len(b) - len(c))


# These are global metrics but Keras works with batches. This could lead to misleading results.
def recall_m(y_true, y_pred):
    true_positives = K.sum(K.round(K.clip(y_true * y_pred, 0, 1)))
    possible_positives = K.sum(K.round(K.clip(y_true, 0, 1)))
    recall = true_positives / (possible_positives + K.epsilon())
    return recall

def precision_m(y_true, y_pred):
    true_positives = K.sum(K.round(K.clip(y_true * y_pred, 0, 1)))
    predicted_positives = K.sum(K.round(K.clip(y_pred, 0, 1)))
    precision = true_positives / (predicted_positives + K.epsilon())
    return precision

def f1_m(y_true, y_pred):
    precision = precision_m(y_true, y_pred)
    recall = recall_m(y_true, y_pred)
    return 2*((precision*recall)/(precision+recall+K.epsilon()))
